# 价格逻辑完整排查报告

## 🎯 问题描述

用户反馈：
- 数据库中所有订单价格都改成了 0.01
- 但测试页面创建的订单显示还是 22 元
- 担心价格逻辑有硬编码，导致价格不能实时更新

---

## 📊 价格数据流分析

### 价格的来源（数据库）

```
activities 集合
  ├── _id: "activity_id"
  ├── title: "校园证件照拍摄"
  ├── price: 22  ← 这里是活动价格
  └── ...

photographers 集合
  ├── _id: "photographer_id"
  ├── name: "史依"
  ├── price: 20  ← 这里是摄影师价格（部分流程使用）
  └── ...
```

---

## 🔍 价格流向分析（3种创建订单的方式）

### 方式1：活动申请页面（推荐流程）✅

**文件：** `miniprogram/pages/activity/apply.js`

**价格逻辑：**
```javascript
// 第363行
const orderData = {
  ...
  totalPrice: this.data.activity.price,  // ✅ 从活动对象读取价格
  ...
};
```

**数据流：**
```
1. 用户选择活动 → 从 activities 集合读取活动信息
2. apply.js 加载活动数据：this.data.activity = { price: 22, ... }
3. 创建订单时：totalPrice = this.data.activity.price
4. 订单保存到数据库：{ totalPrice: 22, ... }
```

**结论：** ✅ **正确！价格是动态读取的，不是硬编码！**

---

### 方式2：注册孩子后下单 ✅

**文件：** `miniprogram/pages/apply/payment.js`

**价格逻辑：**
```javascript
// 第143行
const orderData = {
  ...
  totalPrice: this.data.photographer.price || 20,  // ✅ 从摄影师价格读取
  ...
};
```

**数据流：**
```
1. 用户选择摄影师 → 从 photographers 集合读取摄影师信息
2. payment.js 加载摄影师数据：this.data.photographer = { price: 20, ... }
3. 创建订单时：totalPrice = this.data.photographer.price
4. 如果摄影师没有设置价格，使用默认值 20
```

**结论：** ✅ **正确！价格是动态读取的，有默认值兜底！**

---

### 方式3：测试页面创建订单 ❌ **问题所在！**

**文件：** `miniprogram/pages/test/archive-test.js`

**价格逻辑：**
```javascript
// 第130行
const orderData = {
  ...
  totalPrice: 22,  // ❌ 硬编码！写死的价格！
  ...
};
```

**数据流：**
```
1. 测试页面点击"创建待确认订单"按钮
2. archive-test.js 直接创建订单数据
3. 订单价格 = 22（硬编码）
4. 不管数据库中活动价格是多少，都是 22
```

**结论：** ❌ **错误！价格是硬编码的！**

---

## 🔧 问题解决方案

### 问题1：测试页面价格硬编码

**影响范围：**
- 只影响测试页面创建的订单
- 不影响正常用户下单流程
- 不影响实际支付金额

**修复方案：**

#### 方案A：从活动读取价格（推荐）⭐

```javascript
// archive-test.js 修改后
async createPendingConfirmOrder() {
  try {
    const db = wx.cloud.database();
    
    // 1. 先查询活动信息，获取最新价格
    const activityRes = await db.collection('activities')
      .doc(this.data.defaultActivityId)
      .get();
    
    if (!activityRes.data) {
      this.addLog('❌ 活动不存在');
      return;
    }
    
    const activity = activityRes.data;
    
    // 2. 创建订单，使用活动价格
    const orderData = {
      ...
      totalPrice: activity.price || 0.01,  // ✅ 从活动读取价格
      ...
    };
    
    // 3. 保存订单
    const orderRes = await db.collection('activity_orders').add({
      data: orderData
    });
    
    this.addLog(`✅ 订单创建成功，价格：¥${orderData.totalPrice}`);
  } catch (e) {
    this.addLog(`❌ 创建失败: ${e.message}`);
  }
}
```

#### 方案B：使用配置的测试价格

```javascript
// 在 data 中定义测试价格
data: {
  testPrice: 0.01,  // 测试价格，可以随时修改
  ...
}

// 创建订单时使用
const orderData = {
  ...
  totalPrice: this.data.testPrice,  // 使用配置的测试价格
  ...
};
```

---

## 🚨 潜在隐患排查

### 隐患1：活动价格修改后，旧订单怎么办？

**现状：**
```
订单表：activity_orders
  ├── orderNo: "ORDER123"
  ├── activityId: "activity_id"
  ├── totalPrice: 22  ← 订单创建时的价格（快照）
  └── ...
```

**分析：**
- ✅ **订单价格是快照，不会受活动价格修改影响**
- ✅ 这是正确的设计！确保历史订单价格不变
- ✅ 用户支付的是订单创建时的价格

**结论：** ✅ **无隐患！设计正确！**

---

### 隐患2：订单显示价格是否会变？

**订单列表显示：**
```javascript
// orders.wxml
<text class="order-price">¥{{item.totalPrice}}</text>
```

**数据来源：**
```javascript
// orders.js 第245行
if (!order.totalPrice && order.price !== undefined) {
  order.totalPrice = order.price;  // 兼容旧数据
}
```

**分析：**
- ✅ 订单列表直接显示 `order.totalPrice`（订单表中的价格）
- ✅ 不会从 activities 集合重新读取价格
- ✅ 显示的是订单创建时的价格快照

**结论：** ✅ **无隐患！显示逻辑正确！**

---

### 隐患3：支付金额是否会变？

**支付逻辑：**
```javascript
// orders.js 第387行
await wx.cloud.callFunction({
  name: 'unifiedOrder',
  data: {
    ...
    totalFee: Math.round(order.totalPrice * 100),  // ✅ 使用订单价格
    ...
  }
});
```

**活动申请支付：**
```javascript
// apply.js 第443行
const totalFee = Math.round(totalPrice * 100);  // ✅ 使用订单创建时的价格
```

**分析：**
- ✅ 支付金额来自订单的 `totalPrice` 字段
- ✅ 不会从 activities 集合重新读取
- ✅ 支付的是订单创建时的价格

**结论：** ✅ **无隐患！支付逻辑正确！**

---

### 隐患4：如果活动价格改了，新订单会用新价格吗？

**测试场景：**
```
1. 活动原价：22 元
2. 修改活动价格为 0.01 元
3. 用户创建新订单
4. 新订单价格应该是多少？
```

**分析：**

**方式1（活动申请）：**
```javascript
// apply.js
onLoad(options) {
  // 从数据库重新加载活动信息
  const activity = await db.collection('activities')
    .doc(activityId)
    .get();
  
  this.setData({ activity: activity.data });
}

// 创建订单时
totalPrice: this.data.activity.price  // ✅ 会使用最新的价格 0.01
```

**方式2（注册孩子下单）：**
```javascript
// payment.js
totalPrice: this.data.photographer.price || 20
// ✅ 如果摄影师价格改了，会使用新价格
```

**方式3（测试页面）：**
```javascript
// archive-test.js
totalPrice: 22  // ❌ 写死的，不会变
```

**结论：**
- ✅ **正常用户下单：会使用最新价格**
- ❌ **测试页面下单：还是旧价格（需要修复）**

---

## 🎯 总结

### ✅ 正常流程：无问题！

| 订单来源 | 价格来源 | 是否实时 | 状态 |
|---------|----------|---------|------|
| 活动申请页面 | `activity.price` | ✅ 是 | ✅ 正确 |
| 注册孩子下单 | `photographer.price` | ✅ 是 | ✅ 正确 |
| 订单列表显示 | `order.totalPrice` | ✅ 快照 | ✅ 正确 |
| 支付金额 | `order.totalPrice` | ✅ 快照 | ✅ 正确 |

### ❌ 测试页面：有问题！

| 订单来源 | 价格来源 | 是否实时 | 状态 |
|---------|----------|---------|------|
| 测试页面创建订单 | 硬编码 `22` | ❌ 否 | ❌ 需要修复 |

---

## 🔧 修复建议

### 立即修复：

1. **修改测试页面代码**
   - 从 activities 集合读取价格
   - 或使用可配置的测试价格

### 长期优化：

1. **添加价格验证**
   ```javascript
   // 创建订单时验证价格
   if (!orderData.totalPrice || orderData.totalPrice <= 0) {
     throw new Error('订单价格无效');
   }
   ```

2. **添加价格日志**
   ```javascript
   console.log('创建订单 - 价格信息:', {
     来源: 'activity',
     原价: activity.price,
     实付: orderData.totalPrice
   });
   ```

3. **价格修改提醒**
   - 如果管理员修改活动价格
   - 提示："修改后只影响新订单，已有订单价格不变"

---

## 📋 测试清单

- [ ] 修改活动价格为 0.01
- [ ] 正常流程下单，确认订单价格为 0.01
- [ ] 支付时确认金额为 0.01
- [ ] 订单列表显示价格为 0.01
- [ ] 测试页面下单，确认价格来自活动（不是硬编码）

---

**最后更新：2025-10-23**  
**结论：正常用户下单流程无问题！只需修复测试页面的硬编码价格。**

